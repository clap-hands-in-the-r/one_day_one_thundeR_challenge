---
title: "one_day_one_thundeR"
author: "Mael Elegoet"
date: "2024-05-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


```{r, warning=FALSE}
library(dplyr)


```



## RLe and agregate

```{r}
# rle compute lengths and values of runs of equal values in a vector

x <- c("a","a","a","b","b","c","a","a","b","b","b")

table(x)

y <- round(runif(length(x),1,100))

temp <- rle(x)

df <- data.frame(x,y)

aggregate(y~x, df, sum)

group <- rep(seq_along(temp$values),temp$lengths)

# seq_along generates a sort of indice changing each time 
# the new vector value is changing
temp$lengths
temp$values
df
group

df <- cbind(df,group)

aggregate(y~group,df, sum)

```



## Non standard evaluation

```{r}

head(mtcars)
mtcars |> filter(mpg > mean(mpg))


select_rows <- function(data){
    data |> filter(mpg > mean(mpg))    
}

select_rows(mtcars)

# unquoted version
select_rows_unquoted <- function(data,my_colname){
    
    data |> filter({{my_colname}} > mean({{my_colname}}))
}

select_rows_unquoted(mtcars,mpg)

# quoted version

select_rows_quoted <- function(data, my_colname){
    my_colname <- sym(my_colname)
    data |> filter(!!my_colname > mean(!!my_colname))
}

select_rows_quoted(mtcars,"mpg")




```

## What is the tilda?


```{r, warning=FALSE}


mtcars |> head()
mtcars |> mutate_at(vars(mpg,cyl), ~. *2) |> head()

# tilda acts like an anonymous function


```

## Little quirk with subsetting

```{r}
# lorsqu'on ne positionne pas de virgule dans le subsetting
# ce sont les colonnes qui sont touchées
# alors que d'habitude fonction en rows columns
# comme beaucoup 

identical(mtcars[-1], mtcars[,-1])

```

## across fuction since dplyr 1.0.0 replacing _at, _if and _all


```{r}

# previously we had mutate_at, summarize_at, mutate_if, summarize_if, mutate_all, summarize_all
# > replaced by mutate(across()) and summarize(across())

mtcars |> head()
mtcars |> mutate_at(vars(mpg:hp), ~.^2) |> head()

mtcars |> mutate(across(c(mpg:hp), ~.^2)) |> head()


mtcars |> group_by(cyl) |> 
    summarise_at(1:3, mean)

mtcars |> group_by(cyl) |> 
    summarise(across(1:3,mean))

mtcars |> mutate_if(is.numeric, sqrt) |> head() 

mtcars |> mutate(across(where(is.numeric),sqrt)) |> head()

mtcars |> summarize(across(1:5, sum),
                    across(6:7,mean),
                    n=n()) |> head()
    
mtcars |> summarize(across(1:4, sum, .names = 'abc_{col}'))

mtcars |> summarize(across(1:4, sum, .names = '{fn}_{col}'))

mtcars |> summarize(across(1:4, list(sum=sum), .names = '{fn}_{col}'))

mtcars |> summarize(across(1:4, list(sum=sum, mean=mean), .names = '{fn}_{col}'))

```



# Lexical scoping

```{r}
# List all the objects in the current environment

x <- 10
f <- function(x){
    function(){
        y <- 5
        x+y
    }
}

f(5)()

rm(x,f)

#########

f <- function(){
    x <- 1
    y <- 2
    c(x,y)
}
f()

#########

x <- 4
f <- function(){
    x <- 1
    y <- 2
    c(x,y)
}
f()
ls()
rm(f,x)
#########

x <- 4
h <- function(x){
    y <- 5
    i <- function(){
        z <- 7
        c(x,y,z)
    }
    i()
    
}
h(2)
rm(h,x)
##########

x <- 4
f <- function(x){
    x <- 1
    y <- 2
    c(x,y)
}
f(3)
rm(f,x)
##########

x <- 4
f <- function(x){
    y <- 2
    c(x,y)
}
f(3)
rm(f,x)
ls()

##########

j <- function(x){
    y <- 10
    function(){
        c(x,y)
    }
}
k <- j(1)
k()
ls()


##########
rm(j,k,l)
l <- function(x) x+1
m <- function(){
    l <- function(x) x+2
    l(10)
}
m()
#########


n <- function(x) x/2
o <- function(){
    n <- 10
    n(n)
}
o()

#########

j <- function(){
    if (!exists("a")) {
        a <- 1
    } else {
        a <- a +1
    }
    a
}
j()
j()
j()


########

j <- function() x

x <- 10
j()
x <- 11
j()
x <- 70
j()

codetools::findGlobals(j)

g <- function() x+1
codetools::findGlobals(g)
emptyenv()
g <- emptyenv()
g()

########
# A damned tweak by Hadley !

`(` <- function(e1){
    if (is.numeric(e1) & runif(1) > 0.1 ){
        e1 <- e1 +1
    } else {
        e1
    }
}
replicate(1000,(1+2))
table(replicate(1000,(1+2))==4)/1000
ls()
rm(`(`)


########

args <- list(1:10, na.rm = TRUE)
do.call(mean,args)

########
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)
funs




```

# Function call, arguments, partial matching

```{r}

f <- function(abcdef, bcde1, bcgg2){
    list(a = abcdef, b1 = bcde1, b2 = bcgg2)
}

str(f(1,2,3))
str(f(2,3,abcdef = 5))
str(f(2,3,a=7))
str(f(bcg = 10, bcd = 6, abc = 8))

```

# Arguments missing, arguments checking

```{r}

f <- function(x,y){
    c(missing(x),missing(y))
    
}
f()
f(1)
f(1,2)

# 
g <- function(a = 1, b = d){
    d <- a^2 +1  
    d
}

g()
g(10)
g(11)

```



# Infix operator

```{r}
`%+%` <- function(a,b) paste0(a,b)
"This " %+% "is " %+% "a " %+% "long " %+% "string"
`+`(5,7)
`*`(5,7)
sapply(c(5,7,7), `+`, 3)


```

# Environments

```{r}

search()
library(tidyverse)
search()
e1 <- new.env()
search()
e1$a <- 1
search()
ls()
typeof(e1)
exists("x", envir = e1)
exists("a", envir = e1)
globalenv()
environment()
parent.env(e1)
baseenv()

library(pryr)
address(x)
lobstr::obj_addr(x)
where(x)

address(w)

x <- 1:3
address(x)
lobstr::obj_addr(x)
where("x")

e2 <- new.env()
e2$a <- 1:3
address(a)
e2$b <- e2$a
address(b)
where("a")
exists("a",envir = e2)
ls(envir = e2)
address(e2$"a")
e2$c <- 1:3

library(lobstr)
obj_addr(a)
?address
address("a", env = "e2")
inspect("a", env = e2)
inspect("b",env = e2)
#install.packages("envnames")
library(envnames)
get_obj_address(a)
get_obj_address(a, envir = e2)
get_obj_address(b, envir = e2)
# note the difference a b and c are pointing towards a vector 1:3
# but only a and b point to the same memory adress (so the same object I guess)
# c has not been created through copy so it points toward another object
get_obj_address(c,envir = e2)
parent.env(e1)


ls(all.names = TRUE)
ls.str(e1)
ls.str(environment())
t <- environment()
str(t)
get("a", envir = e1)

where

g <- function(x){
    if (!exists("a",inherits = FALSE)) {
        message("Defining a")
        a <- 1
    } else {
        a <- a +1
    }
    a
}

z <- g()

y <- 1
plus <- function(x){
    function() x +1
}
plus_one <- plus(1)
plus_one()

power <- function(exp){
    function(x){
         x^exp
    }
   
}

power2 <- power(2)
x <- 2
power2(x)
x <- 3



```

# Simple plot

```{r}

x <- seq( 0, 2 * pi, length = 100)
sinx <- sin(x)
plot(x, sinx, type = "l")




```


# Selecting in dplyr

```{r}
library(dplyr)
mtcars |> head()
mtcars |> select(starts_with("mp"))
mtcars |> select(contains("i"))
mtcars |> select(ends_with("t"))

mtcars[,c(1,1)]
mtcars |> select(c(1,1))

mtcars |> select(match("^d."))



my_names <- names(mtcars)
my_names
match("^c.", my_names)


```
# Non standard evaluation

```{r}
sample_df <- data.frame(a = 1:5, b = 5:1, c=c(5,3,1,4,1))
sample_df
subset(sample_df, a >=4)
subset(sample_df, b==c)

a <- 10
eval(quote(a), sample_df)

eval(a, sample_df)
# recherche l'objet a dans sample df
# ça semble être l'équivalent de 
sample_df$a

eval(quote(b), sample_df)

subset2 <- function(x, condition) {
    condition_call <- substitute(condition)
    r <- eval(condition_call,x)
    x[r,]
}

subset2(sample_df, a>=4)

sample_df2 <- data.frame(x = 1:10)
subset2(sample_df2, x > 8)

```

