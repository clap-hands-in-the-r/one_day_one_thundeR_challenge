---
title: "one_day_one_thundeR"
author: "Mael Elegoet"
date: "2024-05-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


```{r, warning=FALSE}
library(dplyr)


```



## RLe and agregate

```{r}
# rle compute lengths and values of runs of equal values in a vector

x <- c("a","a","a","b","b","c","a","a","b","b","b")

table(x)

y <- round(runif(length(x),1,100))

temp <- rle(x)

df <- data.frame(x,y)

aggregate(y~x, df, sum)

group <- rep(seq_along(temp$values),temp$lengths)

# seq_along generates a sort of indice changing each time 
# the new vector value is changing
temp$lengths
temp$values
df
group

df <- cbind(df,group)

aggregate(y~group,df, sum)

```



## Non standard evaluation

```{r}

head(mtcars)
mtcars |> filter(mpg > mean(mpg))


select_rows <- function(data){
    data |> filter(mpg > mean(mpg))    
}

select_rows(mtcars)

# unquoted version
select_rows_unquoted <- function(data,my_colname){
    
    data |> filter({{my_colname}} > mean({{my_colname}}))
}

select_rows_unquoted(mtcars,mpg)

# quoted version

select_rows_quoted <- function(data, my_colname){
    my_colname <- sym(my_colname)
    data |> filter(!!my_colname > mean(!!my_colname))
}

select_rows_quoted(mtcars,"mpg")




```

## What is the tilda?


```{r, warning=FALSE}


mtcars |> head()
mtcars |> mutate_at(vars(mpg,cyl), ~. *2) |> head()

# tilda acts like an anonymous function


```

## Little quirk with subsetting

```{r}
# lorsqu'on ne positionne pas de virgule dans le subsetting
# ce sont les colonnes qui sont touchées
# alors que d'habitude fonction en rows columns
# comme beaucoup 

identical(mtcars[-1], mtcars[,-1])

```

## across fuction since dplyr 1.0.0 replacing _at, _if and _all


```{r}

# previously we had mutate_at, summarize_at, mutate_if, summarize_if, mutate_all, summarize_all
# > replaced by mutate(across()) and summarize(across())

mtcars |> head()
mtcars |> mutate_at(vars(mpg:hp), ~.^2) |> head()

mtcars |> mutate(across(c(mpg:hp), ~.^2)) |> head()


mtcars |> group_by(cyl) |> 
    summarise_at(1:3, mean)

mtcars |> group_by(cyl) |> 
    summarise(across(1:3,mean))

mtcars |> mutate_if(is.numeric, sqrt) |> head() 

mtcars |> mutate(across(where(is.numeric),sqrt)) |> head()

mtcars |> summarize(across(1:5, sum),
                    across(6:7,mean),
                    n=n()) |> head()
    
mtcars |> summarize(across(1:4, sum, .names = 'abc_{col}'))

mtcars |> summarize(across(1:4, sum, .names = '{fn}_{col}'))

mtcars |> summarize(across(1:4, list(sum=sum), .names = '{fn}_{col}'))

mtcars |> summarize(across(1:4, list(sum=sum, mean=mean), .names = '{fn}_{col}'))

```



# Lexical scoping

```{r}
# List all the objects in the current environment

x <- 10
f <- function(x){
    function(){
        y <- 5
        x+y
    }
}

f(5)()

rm(x,f)

#########

f <- function(){
    x <- 1
    y <- 2
    c(x,y)
}
f()

#########

x <- 4
f <- function(){
    x <- 1
    y <- 2
    c(x,y)
}
f()
ls()
rm(f,x)
#########

x <- 4
h <- function(x){
    y <- 5
    i <- function(){
        z <- 7
        c(x,y,z)
    }
    i()
    
}
h(2)
rm(h,x)
##########

x <- 4
f <- function(x){
    x <- 1
    y <- 2
    c(x,y)
}
f(3)
rm(f,x)
##########

x <- 4
f <- function(x){
    y <- 2
    c(x,y)
}
f(3)
rm(f,x)
ls()

##########

j <- function(x){
    y <- 10
    function(){
        c(x,y)
    }
}
k <- j(1)
k()
ls()


##########
rm(j,k,l)
l <- function(x) x+1
m <- function(){
    l <- function(x) x+2
    l(10)
}
m()
#########


n <- function(x) x/2
o <- function(){
    n <- 10
    n(n)
}
o()

#########

j <- function(){
    if (!exists("a")) {
        a <- 1
    } else {
        a <- a +1
    }
    a
}
j()
j()
j()


########

j <- function() x

x <- 10
j()
x <- 11
j()
x <- 70
j()

codetools::findGlobals(j)

g <- function() x+1
codetools::findGlobals(g)
emptyenv()
g <- emptyenv()
g()

########
# A damned tweak by Hadley !

`(` <- function(e1){
    if (is.numeric(e1) & runif(1) > 0.1 ){
        e1 <- e1 +1
    } else {
        e1
    }
}
replicate(1000,(1+2))
table(replicate(1000,(1+2))==4)/1000
ls()
rm(`(`)


########

args <- list(1:10, na.rm = TRUE)
do.call(mean,args)

########
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)
funs




```

# Function call, arguments, partial matching

```{r}

f <- function(abcdef, bcde1, bcgg2){
    list(a = abcdef, b1 = bcde1, b2 = bcgg2)
}

str(f(1,2,3))
str(f(2,3,abcdef = 5))
str(f(2,3,a=7))
str(f(bcg = 10, bcd = 6, abc = 8))

```

# Arguments missing, arguments checking

```{r}

f <- function(x,y){
    c(missing(x),missing(y))
    
}
f()
f(1)
f(1,2)

# 
g <- function(a = 1, b = d){
    d <- a^2 +1  
    d
}

g()
g(10)
g(11)

```



# Infix operator

```{r}
`%+%` <- function(a,b) paste0(a,b)
"This " %+% "is " %+% "a " %+% "long " %+% "string"
`+`(5,7)
`*`(5,7)
sapply(c(5,7,7), `+`, 3)


```

# Environments

```{r}

search()
library(tidyverse)
search()
e1 <- new.env()
search()
e1$a <- 1
search()
ls()
typeof(e1)
exists("x", envir = e1)
exists("a", envir = e1)
globalenv()
environment()
parent.env(e1)
baseenv()

library(pryr)
address(x)
lobstr::obj_addr(x)
where(x)

address(w)

x <- 1:3
address(x)
lobstr::obj_addr(x)
where("x")

e2 <- new.env()
e2$a <- 1:3
address(a)
e2$b <- e2$a
address(b)
where("a")
exists("a",envir = e2)
ls(envir = e2)
address(e2$"a")
e2$c <- 1:3

library(lobstr)
obj_addr(a)
?address
address("a", env = "e2")
inspect("a", env = e2)
inspect("b",env = e2)
#install.packages("envnames")
library(envnames)
get_obj_address(a)
get_obj_address(a, envir = e2)
get_obj_address(b, envir = e2)
# note the difference a b and c are pointing towards a vector 1:3
# but only a and b point to the same memory adress (so the same object I guess)
# c has not been created through copy so it points toward another object
get_obj_address(c,envir = e2)
parent.env(e1)


ls(all.names = TRUE)
ls.str(e1)
ls.str(environment())
t <- environment()
str(t)
get("a", envir = e1)

where

g <- function(x){
    if (!exists("a",inherits = FALSE)) {
        message("Defining a")
        a <- 1
    } else {
        a <- a +1
    }
    a
}

z <- g()

y <- 1
plus <- function(x){
    function() x +1
}
plus_one <- plus(1)
plus_one()

power <- function(exp){
    function(x){
         x^exp
    }
   
}

power2 <- power(2)
x <- 2
power2(x)
x <- 3



```

# Simple plot

```{r}

x <- seq( 0, 2 * pi, length = 100)
sinx <- sin(x)
plot(x, sinx, type = "l")




```


# Selecting in dplyr

```{r}
library(dplyr)
mtcars |> head()
mtcars |> select(starts_with("mp"))
mtcars |> select(contains("i"))
mtcars |> select(ends_with("t"))

mtcars[,c(1,1)]
mtcars |> select(c(1,1))

mtcars |> select(match("^d."))



my_names <- names(mtcars)
my_names
match("^c.", my_names)


```
# Non standard evaluation

```{r}
sample_df <- data.frame(a = 1:5, b = 5:1, c=c(5,3,1,4,1))
sample_df
subset(sample_df, a >=4)
subset(sample_df, b==c)

a <- 10
eval(quote(a), sample_df)

eval(a, sample_df)
# recherche l'objet a dans sample df
# ça semble être l'équivalent de 
sample_df$a

eval(quote(b), sample_df)

subset2 <- function(x, condition) {
    condition_call <- substitute(condition)
    r <- eval(condition_call,x)
    x[r,]
}

subset2(sample_df, a>=4)

sample_df2 <- data.frame(x = 1:10)
subset2(sample_df2, x > 8)

```

# Environments and lists

```{r}

modify <- function(x){
    x$a <- 2
    invisible()
}

l_x <- list(a=1)
modify(l_x)
l_x
# modify doesn't modifiy a list, it creates a copy...

e_x <- new.env()
e_x$a <- 1
e_x$a
modify(e_x)
e_x$a
# modify modifies the environment because environments are modified in place


```

# Environments, one possible side effect

```{r}

y <- 1
e1 <- new.env()
get("y", e1)
# returns 1 despite one is not in our environment

# to avoid this side effect, we need to specify the empty environment
# as our parent environment
e2 <- new.env(parent = emptyenv())
get("y", e2)
# returns an error and this is the behavior expected because
# we didn't have an object y in e2

```

# Functional programming with hadley

```{r}

df <- data.frame(replicate(6,sample(c(1:10,-99),6, replace = TRUE)))

names(df) <- letters[1:6]
df
df$a[df$a == -99] <- NA
df$b[df$b == -99] <- NA
df$c[df$c == -99] <- NA
df$d[df$d == -99] <- NA
df$e[df$e == -99] <- NA
df$f[df$f == -99] <- NA

df

df <- data.frame(replicate(6,sample(c(1:10,-99),6, replace = TRUE)))
names(df) <- letters[1:6]
fix_missing <- function(x){
    x[x == -99] <- NA
    x
}

df
df$a <- fix_missing(df$a)
df$b <- fix_missing(df$b)

df <- data.frame(replicate(6,sample(c(1:10,-99),6, replace = TRUE)))
names(df) <- letters[1:6]

df2 <- lapply(df, fix_missing)
df2
# df2 is a list
as.data.frame(df2)

# a little trick assign to object df2[] will constraint the list to 
# the structure of a data frame

df3 <- data.frame(matrix("", nrow=6, ncol=6))
df3

# lapply is called a functionnal because it takes a function as argument
df3[] <- lapply(df,fix_missing)
df3

# rewritting lapply

my_apply <- function(x){
    out <- vector("list",length(x))
    for (i in seq_along(x)) {
        out[[i]] <- fix_missing(x[[i]])
    }
    out
}
df[] <- my_apply(df)
df


my_vec <- sample(c(1:100, NA), 50, replace = TRUE)
my_df <- data.frame(replicate(10,sample(c(1:100, NA), 50, replace = TRUE)))
summary_1 <- function(x) {
    c(sum(x), mean(x), median(x), sd(x), IQR(x))
}

lapply(my_vec,summary_1)
summary_1(my_vec)

summary_2 <- function(x){
    funs <- c(sum,mean,median,sd, IQR)
    y <- x
    lapply(funs, function(f) f(x, na.rm = TRUE))
}

summary_2(my_vec)


my_vec <- sample(c(1:100,rep(NA,10)), 50, replace = TRUE)
my_df <- data.frame(replicate(10,sample(c(1:100, NA), 50, replace = TRUE)))
summary_1 <- function(x) {
    c(sum(x), mean(x), median(x), sd(x), IQR(x))
}

lapply(my_vec,summary_1)
summary_1(my_vec)

summary_2 <- function(x){
    funs <- c(sum,mean,median,sd, IQR)
    y <- x
    lapply(funs, function(f) f(x, na.rm = TRUE))
}

summary_2(my_vec)


```

# Anonymous fonction ie fonction without a name

```{r}
unlist(lapply(mtcars, function(x) length(unique(x))))
unlist(lapply(mtcars, function(x) sum(x)))

function(x)3()
# not a function
(function(x) 3)()
# this one is a fontion it works

(function(x) x + 3)(10)
# it works

f <- function(x) x + 3
f(10)
# it is the same

```

# trying to understand deeper the tilda ~ leading to call and language

```{r}
my_obj <- a ~ b
str(my_obj)
# my_obj is of class formula with a typeof "language" and a mode "call"
typeof(my_obj)
mode(my_obj)
help(`~`)
# `~ is from base R. help is not of real help 
is.call(my_obj)
# returns true
cl <- call("round",10.5)
typeof(cl) #language
eval(cl) # returns 10
a <- 10.5
call("round",a) # returns round(10.5)
eval(call("round",a)) # returns 10
call("round", quote(a)) # returns round(a)
eval(call("round", quote(a))) # retunrs 10


```

# Exercice with Hadley

```{r}
# Use lapply() and an anonymous function to find the coefficient of variation (the standard deviation divided by the mean) for all columns in the mtcars dataset

unlist(lapply(mtcars, function(x) sd(x)/mean(x)))

?do.call
do.call(mean,list(1:10))


```
# List of functions

```{r}

compute_mean <- list(
    # be careful i don't know why now, but if 
    # we built functions with assignment and not with equal sign
    # it doesn't work
    baase = function(x) mean(x),
    suum = function(x) sum(x)/length(x),
    manuual = function(x){
        total <- 0
        n <- length(x)
        for (i in seq_along(x)) {
            total <- total + x[i]/n
        }
        total
    }
)

x <- runif(1e7)

# we need to subset with double brackets here
system.time(compute_mean$baase(x))
system.time(compute_mean[[2]](x))
system.time(compute_mean[["manuual"]](x))

lapply(compute_mean, function(f) f(x))

lapply(compute_mean, function(f) system.time(f(x)))


```
# Environments with Garett Gromlund

```{r}

show_env <- function() {
    list(
        ran.in = environment(),
        parent = parent.env(environment()),
        objects = ls.str(envir = environment())
    )
}

show_env()
# every function has an environment
environment(show_env)
environment(mean)

# Function composition

```



```{r}

power <- function(exp){
    print(environment())
    function(x){
        x^exp
    }
}

square <- power(2)
cube <- power(3)

square(3)
cube(2)

library(pryr)
parenvs(square)
environment(square)
parent.env(square)
square
environment(parenvs)

```

# Split function to split a vector in groups

```{r}
my_vec <- c(1:5, c(NA,1), rep(3,2))
my_groups <- c(rep("group A",5), rep("group B", 2), rep("group C", 2))

my_vec_by_groups <- split(my_vec, my_groups)
my_vec_by_groups

# reverse operation
unsplit(my_vec_by_groups,my_groups)


```

# Sink to print text or output in a file

```{r}
# Sink acts like a recorder. You open it with sink(file = "XXX.txt")
# you close it with sink()
# all actions you make in between are recorder to the output
# it best works with cat() to print something (cleaner)
# but also works with print() -- less clean

sink(file = "my_first_sink_file.txt")
cat("This is my first sink file")
sink()
file.show("my_first_sink_file.txt")
file.remove("my_first_sink_file.txt")
sink(file = "my_second_sink_file_is_a_df.txt")
cat("This is my second sink file with df mtcars")
mtcars
sink()
file.show("my_second_sink_file_is_a_df.txt")
file.remove("my_second_sink_file_is_a_df.txt")

```

# Check installed packages

```{r}
my_inst_packages <- installed.packages()
my_inst_packages |> str()
attributes(my_inst_packages)
# I don't really understand the structure of the object created but it works
"dplyr" %in% my_inst_packages # returns TRUE
"sf" %in% my_inst_packages
"leaflet" %in% my_inst_packages
"caret" %in% my_inst_packages
"tidyquant" %in% my_inst_packages # returns FALSE
c("caret", "tidyquant") %in% my_inst_packages # returns TRUE FALSE

```

# Using cut and split

```{r}
my_vec <- 1:16
chunk_size <- 4
seq_along(my_vec) # returns the same content as my_vec
ceiling(6.8) # returns 7
floor(6.8) # returns 6
ceiling(seq_along(my_vec)/chunk_size) # returns a vector 
# [1] 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4
chunks <- split(my_vec, ceiling(seq_along(my_vec)/chunk_size))
chunks_list <- list(chunks = chunks)

my_vect <- 1:10
chunk_size <- 3
breakpts <- seq(0,length(my_vect)+2, by = chunk_size)
breakpts
chunks <- cut(seq_along(my_vect),breaks = breakpts, labels = FALSE)
chunks
chunks <- split(my_vect,chunks)
chunks

```

# Interest of seq_along

```{r}
a <- 1:10
seq_along(a) # returns the same as calling a
b <- letters[1:10]
seq_along(b) # b is a vector of letters and seq_along 
# is more interesting in this case


```

# Add one and lexical scoping again with Hadley



```{r}

add_one_v1 <- function(){
    i <- 0
    function(){
        i <- i+1
    }
    i
}

add_one_v1() #returns 0

i <- 0
add_one_v2 <- function(){
    function(){
        i <- i+1
    }
    i
}
add_one_v2() # returns 0
add_one_v2() # returns 0 again

i <- 0
add_one_v3 <- function(){
    function(){
        i <<- i + 1
    }
    i

}
add_one_v3()
add_one_v3()() # doesn't work "attempt to apply non function

# notice the tiny difference that makes a big one in results
# when a function is nested inside a function 
# we need two calls to the more external function
# or create a function with the coupled function
# both ways are equivalents
i <- 0
add_one_v3_bis <- function(){
    
    function(){
        i <<- i + 1
        i
    }
    
}
add_one_v3_bis()() # returns 1 and increment at each call
plus_one <- add_one_v3_bis()
plus_one() # increment increment etc. equivalent to double call with 
# double parenthesis

i <- 0
add_one_v4 <- function(){
    i <<- i +1
    i
}
add_one_v4() # returns 1
add_one_v4() # returns 2
add_one_v4() # returns 3




```

